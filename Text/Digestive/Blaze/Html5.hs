{-# LANGUAGE OverloadedStrings #-}
module Text.Digestive.Blaze.Html5
    ( BlazeFormHtml
    , inputText
    , inputTextArea
    , inputTextRead
    , inputPassword
    , inputCheckBox
    , inputRadio
    , label
    , errors
    , childErrors
    , module Text.Digestive.Html
    ) where

import Control.Monad (forM_, unless, when)
import Data.Maybe (fromMaybe)
import Data.Monoid (mempty)

import Text.Blaze.Html5 (Html, (!))
import qualified Text.Blaze.Html5 as H
import qualified Text.Blaze.Html5.Attributes as A

import Text.Digestive.Types
import qualified Text.Digestive.Common as Common
import Text.Digestive.Html

-- | Form HTML generated by blaze
--
type BlazeFormHtml = FormHtml Html

-- | 'applyClasses' instantiated for blaze
--
applyClasses' :: [FormHtmlConfig -> [String]]  -- ^ Labels to apply
              -> FormHtmlConfig                -- ^ Label configuration
              -> Html                          -- ^ HTML element
              -> Html                          -- ^ Resulting element
applyClasses' = applyClasses $ \element value ->
    element ! A.class_ (H.stringValue value)

-- | Checks the input element when the argument is true
--
checked :: Bool -> Html -> Html
checked False x = x
checked True  x = x ! A.checked "checked"

inputText :: (Monad m, Functor m)
          => Maybe String
          -> Form m String e BlazeFormHtml String
inputText = Common.inputString $ \id' inp -> FormHtml $ \cfg ->
    applyClasses' [htmlInputClasses] cfg $
        H.input ! A.type_ "text"
                ! A.name (H.stringValue $ show id')
                ! A.id (H.stringValue $ show id')
                ! A.value (H.stringValue $ fromMaybe "" inp)

inputTextArea :: (Monad m, Functor m)
              => Maybe Int                             -- ^ Rows
              -> Maybe Int                             -- ^ Columns
              -> Maybe String                          -- ^ Default input
              -> Form m String e BlazeFormHtml String  -- ^ Result
inputTextArea r c = Common.inputString $ \id' inp -> FormHtml $ \cfg ->
    applyClasses' [htmlInputClasses] cfg $ rows r $ cols c $
        H.textarea ! A.name (H.stringValue $ show id')
                   ! A.id (H.stringValue $ show id')
                   $ H.string $ fromMaybe "" inp
  where
    rows Nothing = id
    rows (Just x) = (! A.rows (H.stringValue $ show x))
    cols Nothing = id
    cols (Just x) = (! A.cols (H.stringValue $ show x))

inputTextRead :: (Monad m, Functor m, Show a, Read a)
              => String
              -> Maybe a
              -> Form m String String BlazeFormHtml a
inputTextRead error' = flip Common.inputRead error' $ \id' inp ->
    FormHtml $ \cfg -> applyClasses' [htmlInputClasses] cfg $
        H.input ! A.type_ "text"
                ! A.name (H.stringValue $ show id')
                ! A.id (H.stringValue $ show id')
                ! A.value (H.stringValue $ fromMaybe "" inp)

inputPassword :: (Monad m, Functor m)
              => Form m String e BlazeFormHtml String
inputPassword = flip Common.inputString Nothing $ \id' inp ->
    FormHtml $ \cfg -> applyClasses' [htmlInputClasses] cfg $
        H.input ! A.type_ "password"
                ! A.name (H.stringValue $ show id')
                ! A.id (H.stringValue $ show id')
                ! A.value (H.stringValue $ fromMaybe "" inp)

inputCheckBox :: (Monad m, Functor m)
              => Bool
              -> Form m String e BlazeFormHtml Bool
inputCheckBox inp = flip Common.inputBool inp $ \id' inp' ->
    FormHtml $ \cfg -> applyClasses' [htmlInputClasses] cfg $
        checked inp' $ H.input ! A.type_ "checkbox"
                               ! A.name (H.stringValue $ show id')
                               ! A.id (H.stringValue $ show id')

inputRadio :: (Monad m, Functor m, Eq a)
           => Bool                             -- ^ Use @<br>@ tags
           -> a                                -- ^ Default option
           -> [(a, Html)]                      -- ^ Choices with their names
           -> Form m String e BlazeFormHtml a  -- ^ Resulting form
inputRadio br def choices = Common.inputChoice toView def (map fst choices)
  where
    toView group id' sel val = FormHtml $ \cfg -> do
        applyClasses' [htmlInputClasses] cfg $ checked sel $
            H.input ! A.type_ "radio"
                    ! A.name (H.stringValue $ show group)
                    ! A.value (H.stringValue id')
                    ! A.id (H.stringValue id')
        H.label ! A.for (H.stringValue id')
                $ fromMaybe mempty $ lookup val choices
        when br H.br

label :: Monad m
      => String
      -> Form m i e BlazeFormHtml ()
label string = Common.label $ \id' -> FormHtml $ \cfg ->
    applyClasses' [htmlLabelClasses] cfg $
        H.label ! A.for (H.stringValue $ show id')
                $ H.string string

errorList :: [String] -> BlazeFormHtml
errorList errors' = FormHtml $ \cfg -> unless (null errors') $
    H.ul $ forM_ errors' $ applyClasses' [htmlErrorClasses] cfg
                         . H.li . H.string

errors :: Monad m
       => Form m i String BlazeFormHtml ()
errors = Common.errors errorList

childErrors :: Monad m
            => Form m i String BlazeFormHtml ()
childErrors = Common.childErrors errorList
